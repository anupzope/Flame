#include <flame.hh>
#include <plot.hh>
#include <initialConditions.hh>
#include <eos.hh>

$include "FVM.lh"
$include "flame.lh"

#include <sstream>

#define GLOG_USE_GLOG_EXPORT
#include <glog/logging.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

namespace flame {

// =============================================================================

$rule optional(initialConditions) {
}

$rule optional(initialConditionsTGV) {
}

$rule optional(initialConditionRegions) {
}

// =============================================================================

$rule unit(gagePressure_ic), constraint(geom_cells) {
  $gagePressure_ic = 0.0;
}

$rule unit(velocity_ic), constraint(geom_cells) {
  $velocity_ic = Loci::vector3d<double>(0.0, 0.0, 0.0);
}

$rule unit(temperature_ic), constraint(geom_cells) {
  $temperature_ic = 0.0;
}

$rule unit(speciesY_ic <- Ns),
constraint(geom_cells, multiSpecies), prelude {
  $speciesY_ic.setVecSize(*$Ns);
} {
  $speciesY_ic = mk_Scalar(0.0);
}

// =============================================================================

$rule singleton(thermoIC <- initialConditions), constraint(UNIVERSE) {
  $[Once] {
    LOG(INFO) << "Parsing thermodynamic variables from initialConditions";
  }
  
  int error = 0;
  std::ostringstream errmsg;
  
  error += getThermoSpec(
    $initialConditions, "initialConditions",
    "pressure", "temperature", "density",
     $thermoIC, errmsg
  );
  
  if(error) {
    $[Once] {
      LOG(ERROR) << errmsg.str();
    }
    Loci::Abort();
  }
}

$rule singleton(velocityIC <- initialConditions), constraint(UNIVERSE) {
  $[Once] {
    LOG(INFO) << "Parsing velocity variables from initialConditions";
  }
  
  int error = 0;
  std::ostringstream errmsg;
  
  error += getVelSpec(
    $initialConditions, "initialConditions",
    "velocity", "Mach",
    $velocityIC, errmsg
  );
  
  if(error) {
    $[Once] {
      LOG(ERROR) << errmsg.str();
    }
    Loci::Abort();
  }
}

$rule singleton(speciesIC <- initialConditions, Ns), constraint(UNIVERSE) {
  $[Once] {
    LOG(INFO) << "Parsing species fractions from initialConditions";
  }
  
  int error = 0;
  std::ostringstream errmsg;
  
  error += getSpeciesSpec(
    $initialConditions, "initialConditions",
    "molarFractions", "massFractions", $Ns,
     $speciesIC, errmsg
  );
  
  if(error) {
    $[Once] {
      LOG(ERROR) << errmsg.str();
    }
    Loci::Abort();
  }
}


$rule singleton(icMixtureW, icMixtureR <- speciesW, Runiv),
constraint(singleSpecies) {
  $icMixtureW = $speciesW[0];
  $icMixtureR = $Runiv/$speciesW[0];
}

$rule singleton(icMixtureCp <- speciesCp_Constant),
constraint(singleSpecies, caloricallyPerfectGas) {
  $icMixtureCp = $speciesCp_Constant[0];
}

$rule singleton(icMixtureW, icMixtureR <- speciesIC, speciesW, Runiv, Ns),
constraint(multiSpecies) {
  double const * sW = &$speciesW[0];
  double const * F = &$speciesIC.fractions.data[0];

  switch($speciesIC.type) {
  case SPECIES_SPEC_X:
    $icMixtureW = mixture_mW_from_X_sW($Ns, F, sW);
    $icMixtureR = $Runiv/$icMixtureW;
    break;
  case SPECIES_SPEC_Y:
    $icMixtureW = mixture_mW_from_Y_sW($Ns, F, sW);
    $icMixtureR = $Runiv/$icMixtureW;
    break;
  }
}

$rule singleton(icSpeciesY <- speciesIC, icMixtureW, speciesW, Runiv, Ns),
constraint(multiSpecies) {
  $icSpeciesY.resize($Ns);

  switch($speciesIC.type) {
  case SPECIES_SPEC_X:
    mixture_Y_from_X_sW_mW($Ns, &$icSpeciesY[0], &$speciesIC.fractions.data[0], &$speciesW[0], $icMixtureW);
    break;
  case SPECIES_SPEC_Y:
    for(int i = 0; i < $Ns; ++i) {
      $icSpeciesY[i] = $speciesIC.fractions.data[i];
    }
    break;
  }
}

$rule singleton(icMixtureCp <- icMixtureR, speciesCp_Constant, icSpeciesY, Ns),
constraint(multiSpecies, caloricallyPerfectGas) {
  $icMixtureCp = mixture_Cp_from_sCp_Y($Ns, &$speciesCp_Constant[0], &$icSpeciesY[0]);
}
    
$rule singleton(
  icGagePressure, icTemperature
  <-
  thermoIC, icMixtureR, Pambient
), constraint(thermallyPerfectGas) {
  switch($thermoIC.type) {
  case THERMO_SPEC_PT:
    $icGagePressure = $thermoIC.pressure - $Pambient;
    $icTemperature = $thermoIC.temperature;
    break;
  case THERMO_SPEC_DT:
    $icGagePressure = eos_TP_P_from_r_T_R($thermoIC.density, $thermoIC.temperature, $icMixtureR) - $Pambient;
    $icTemperature = $thermoIC.temperature;
    break;
  case THERMO_SPEC_DP:
    $icGagePressure = $thermoIC.pressure - $Pambient;
    $icTemperature = eos_TP_T_from_r_P_R($thermoIC.density, $thermoIC.pressure, $icMixtureR);
    break;
  }
}

$rule singleton(icSpeedOfSound <- icTemperature, icMixtureCp, icMixtureR),
constraint(thermallyPerfectGas) {
  $icSpeedOfSound = eos_TP_a_from_Cp_R_T($icMixtureCp, $icMixtureR, $icTemperature);
}

$rule singleton(icVelocity <- icSpeedOfSound, velocityIC),
constraint(thermallyPerfectGas) {
  switch($velocityIC.type) {
  case VEL_SPEC_VELOCITY:
    $icVelocity = $velocityIC.value;
    break;
  case VEL_SPEC_MACH:
    $icVelocity = $icSpeedOfSound*$velocityIC.value;
    break;
  }
}

// -----------------------------------------------------------------------------

$rule apply(gagePressure_ic <- icGagePressure)[Loci::Summation],
constraint(withoutICDirectory) {
  join($gagePressure_ic, $icGagePressure);
}

$rule apply(velocity_ic <- icVelocity)[Loci::Summation],
constraint(withoutICDirectory) {
  join($velocity_ic, $icVelocity);
}

$rule apply(temperature_ic <- icTemperature)[Loci::Summation],
constraint(withoutICDirectory) {
  join($temperature_ic, $icTemperature);
}

$rule apply(speciesY_ic <- icSpeciesY, Ns)[Loci::Summation],
constraint(withoutICDirectory) {
  for(int i = 0; i < $Ns; ++i) {
    $speciesY_ic[i] += $icSpeciesY[i];
  }
}

// =============================================================================

$rule singleton(
  nICRegions, nICRegionStates, thermoICRegion, velocityICRegion,
  speciesICRegion, geomICRegion, stateICRegion
  <- initialConditionRegions, Ns
), option(disable_threading) {
  std::string olName = "initialConditionRegions";
  Loci::options_list const & ol = $initialConditionRegions;
  std::map<std::string, int> stateMap;
  std::map<std::string, int> regionMap;
  std::map<int, int> regionStateMap;
  int stateIdx = 0, regionIdx = 0;

  if(ol.optionExists("defaultState")) {
    std::stringstream errmsg;
    ThermoSpec thermoSpec;
    VelSpec velSpec;
    SpeciesSpec speciesSpec;
    if(getStateSpec(
      ol, "defaultState", "state",
      "pressure", "temperature", "density",
      "velocity", "Mach",
      "molarFractions", "massFractions",
      $Ns,
      thermoSpec, velSpec, speciesSpec,
      errmsg
    )) {
      LOG(ERROR) << olName << " : " << errmsg.str();
      Loci::Abort();
    }

    $thermoICRegion.push_back(thermoSpec);
    $velocityICRegion.push_back(velSpec);
    $speciesICRegion.push_back(speciesSpec);

    stateMap.insert(std::pair<std::string, int>("default", stateIdx++));
  } else {
    LOG(ERROR) << "defaultState required in " << olName;
    Loci::Abort();
  }

  options_list::option_namelist nl = ol.getOptionNameList();
  options_list::option_namelist::const_iterator nliter = nl.begin();  
  while(nliter != nl.end()) {
    if(nliter->compare(0, 5, "state") == 0) {
      std::string stateName = nliter->substr(5, std::string::npos);
      std::stringstream errmsg;
      ThermoSpec thermoSpec;
      VelSpec velSpec;
      SpeciesSpec speciesSpec;
      if(getStateSpec(
        ol, *nliter, "state",
        "pressure", "temperature", "density",
        "velocity", "Mach",
        "molarFractions", "massFractions",
        $Ns,
        thermoSpec, velSpec, speciesSpec,
        errmsg
      )) {
        LOG(ERROR) << olName << " : " << errmsg.str();
        Loci::Abort();
      }

      $thermoICRegion.push_back(thermoSpec);
      $velocityICRegion.push_back(velSpec);
      $speciesICRegion.push_back(speciesSpec);

      stateMap.insert(std::pair<std::string, int>(stateName, stateIdx++));
    }
    ++nliter;
  }

  nliter = nl.begin();
  while(nliter != nl.end()) {
    if(nliter->compare(0, 6, "region") == 0) {
      std::string regionName = nliter->substr(6, std::string::npos);
      std::ostringstream errmsg;
      ICRegionGeom * geom;
      if(getRegionGeom(ol, *nliter, &geom, errmsg)) {
        LOG(ERROR) << olName << " : " << *nliter << " : " << errmsg.str();
        Loci::Abort();
      } else {
        $geomICRegion.push_back(Loci::CPTR<flame::ICRegionGeom>(geom));
        regionMap.insert(std::pair<std::string, int>(regionName, regionIdx++));
      }
    }
    ++nliter;
  }

  $nICRegions = regionIdx;
  $nICRegionStates = stateIdx;

  $stateICRegion.resize(regionIdx);
  nliter = nl.begin();
  while(nliter != nl.end()) {
    if(nliter->compare(0, 17, "setStateForRegion") == 0) {
      std::string regionName = nliter->substr(17, std::string::npos);
      if(regionMap.find(regionName) == regionMap.end()) {
        LOG(ERROR) << olName << " : " << *nliter << " region with name "
                   << regionName << " not defined";
        Loci::Abort();
      }

      Loci::option_value_type type = ol.getOptionValueType(*nliter);
      if(type == Loci::STRING || type == Loci::NAME) {
        std::string stateName;
        ol.getOption(*nliter, stateName);
        if(stateMap.find(stateName) == stateMap.end()) {
          LOG(ERROR) << olName << " : " << *nliter << " state with name "
                     << stateName << " not defined";
          Loci::Abort();
        }

        $stateICRegion[regionMap[regionName]] = stateMap[stateName];
      } else {
        LOG(ERROR) << olName << " : " << *nliter << " must be a STRING or NAME";
        Loci::Abort();
      }
    }
    ++nliter;
  }
}

$rule singleton(
  icRegionMixtureW, icRegionMixtureR
  <- nICRegionStates, speciesICRegion, speciesW, Runiv, Ns
), constraint(singleSpecies) {
  $icRegionMixtureW.resize($nICRegionStates);
  $icRegionMixtureR.resize($nICRegionStates);

  for(int i = 0; i < $nICRegionStates; ++i) {
    $icRegionMixtureW[i] = $speciesW[0];
    $icRegionMixtureR[i] = $Runiv/$speciesW[0];
  }
}

$rule singleton(
  icRegionMixtureW, icRegionMixtureR
  <- nICRegionStates, speciesICRegion, speciesW, Runiv, Ns
), constraint(multiSpecies) {
  $icRegionMixtureW.resize($nICRegionStates);
  $icRegionMixtureR.resize($nICRegionStates);

  double const * sW = &$speciesW[0];

  for(int i = 0; i < $nICRegionStates; ++i) {
    double const * F = &$speciesICRegion[i].fractions.data[0];

    switch($speciesICRegion[i].type) {
    case SPECIES_SPEC_X:
      $icRegionMixtureW[i] = mixture_mW_from_X_sW($Ns, F, sW);
      $icRegionMixtureR[i] = $Runiv/$icRegionMixtureW[i];
      break;
    case SPECIES_SPEC_Y:
      $icRegionMixtureW[i] = mixture_mW_from_Y_sW($Ns, F, sW);
      $icRegionMixtureR[i] = $Runiv/$icRegionMixtureW[i];
      break;
    }
  }
}

$rule singleton(
  icRegionSpeciesY <- nICRegionStates, speciesICRegion, icRegionMixtureW, speciesW, Ns
), constraint(multiSpecies) {
  $icRegionSpeciesY.resize($nICRegionStates);

  double const * sW = &$speciesW[0];

  for(int i = 0; i < $nICRegionStates; ++i) {
    $icRegionSpeciesY[i].resize($Ns);

    double const mW = $icRegionMixtureW[i];
    double * Y = &$icRegionSpeciesY[i][0];
    double const * F = &$speciesICRegion[i].fractions.data[0];

    switch($speciesICRegion[i].type) {
    case SPECIES_SPEC_X:
      mixture_Y_from_X_sW_mW($Ns, Y, F, sW, mW);
      break;
    case SPECIES_SPEC_Y:
      for(int i = 0; i < $Ns; ++i) {
        Y[i] = F[i];
      }
      break;
    }
  }
}

$rule singleton(icRegionMixtureCp <- nICRegionStates, speciesCp_Constant),
constraint(singleSpecies, caloricallyPerfectGas) {
  $icRegionMixtureCp.resize($nICRegionStates);
  for(int i = 0; i < $nICRegionStates; ++i) {
    $icRegionMixtureCp[i] = $speciesCp_Constant[i];
  }
}

$rule singleton(icRegionMixtureCp <- nICRegionStates, icRegionSpeciesY, speciesCp_Constant, Ns),
constraint(multiSpecies, caloricallyPerfectGas) {
  $icRegionMixtureCp.resize($nICRegionStates);
  for(int i = 0; i < $nICRegionStates; ++i) {
    $icRegionMixtureCp[i] = mixture_Cp_from_sCp_Y($Ns, &$speciesCp_Constant[0], &$icRegionSpeciesY[i][0]);
  }
}

$rule singleton(
  icRegionGagePressure, icRegionTemperature
  <-
  nICRegionStates, thermoICRegion, icRegionMixtureR, Pambient
), constraint(thermallyPerfectGas) {
  $icRegionTemperature.resize($nICRegionStates);
  $icRegionGagePressure.resize($nICRegionStates);
  for(int i = 0; i < $nICRegionStates; ++i) {
    double const T = $thermoICRegion[i].temperature;
    double const r = $thermoICRegion[i].density;
    double const P = $thermoICRegion[i].pressure;
    double const R = $icRegionMixtureR[i];

    switch($thermoICRegion[i].type) {
    case THERMO_SPEC_PT:
      $icRegionGagePressure[i] = P - $Pambient;
      $icRegionTemperature[i] = T;
      break;
    case THERMO_SPEC_DT:
      $icRegionGagePressure[i] = eos_TP_P_from_r_T_R(r, T, R) - $Pambient;
      $icRegionTemperature[i] = T;
      break;
    case THERMO_SPEC_DP:
      $icRegionGagePressure[i] = P - $Pambient;
      $icRegionTemperature[i] = eos_TP_T_from_r_P_R(r, P, R);
      break;
    }
  }
}

$rule singleton(
  icRegionSpeedOfSound <- nICRegionStates, icRegionTemperature,
  icRegionMixtureCp, icRegionMixtureR
), constraint(thermallyPerfectGas) {
  $icRegionSpeedOfSound.resize($nICRegionStates);
  for(int i = 0; i < $nICRegionStates; ++i) {
    double const Cp = $icRegionMixtureCp[i];
    double const T = $icRegionTemperature[i];
    double const R = $icRegionMixtureR[i];
    $icRegionSpeedOfSound[i] = eos_TP_a_from_Cp_R_T(Cp, R, T);
  }
}

$rule singleton(
  icRegionVelocity <- nICRegionStates, icRegionSpeedOfSound, velocityICRegion
), constraint(thermallyPerfectGas) {
  $icRegionVelocity.resize($nICRegionStates);

  for(int i = 0; i < $nICRegionStates; ++i) {
    switch($velocityICRegion[i].type) {
    case VEL_SPEC_VELOCITY:
      $icRegionVelocity[i] = $velocityICRegion[i].value;
      break;
    case VEL_SPEC_MACH:
      $icRegionVelocity[i] = $icRegionSpeedOfSound[i]*$velocityICRegion[i].value;
      break;
    }
  }
}

$rule pointwise(cellICRegionIdx <- geomICRegion, stateICRegion, cellcenter) {
  $cellICRegionIdx = 0;
  const int sz = $geomICRegion.size();
  for(int i = 0; i < sz; ++i) {
    if((*$geomICRegion[i]).in($cellcenter.x, $cellcenter.y, $cellcenter.z)) {
      $cellICRegionIdx = $stateICRegion[i];
      break;
    }
  }
}

// -----------------------------------------------------------------------------

$rule apply(gagePressure_ic <- cellICRegionIdx, icRegionGagePressure)[Loci::Summation],
  constraint(withoutICDirectory, geom_cells) {
  join($gagePressure_ic, $icRegionGagePressure[$cellICRegionIdx]);
}

$rule apply(velocity_ic <- cellICRegionIdx, icRegionVelocity)[Loci::Summation],
  constraint(withoutICDirectory, geom_cells) {
  join($velocity_ic, $icRegionVelocity[$cellICRegionIdx]);
}

$rule apply(temperature_ic <- cellICRegionIdx, icRegionTemperature)[Loci::Summation],
  constraint(withoutICDirectory, geom_cells) {
  join($temperature_ic, $icRegionTemperature[$cellICRegionIdx]);
}

$rule apply(speciesY_ic <- cellICRegionIdx, icRegionSpeciesY, Ns)[Loci::Summation],
  constraint(withoutICDirectory, geom_cells) {
  for(int i = 0; i < $Ns; ++i) {
    $speciesY_ic[i] += $icRegionSpeciesY[$cellICRegionIdx][i];
  }
}

// =============================================================================

$rule singleton(tgvICParameters <- initialConditionsTGV) {
  $[Once] {
    LOG(INFO) << "Parsing initialConditionsTGV";
  }
  
  bool XrefSet = false;
  Loci::vector3d<double> Xref;
  
  bool LrefSet = false;
  Loci::vector3d<double> Lref;
  
  bool KrefSet = false;
  Loci::vector3d<double> Kref;
  
  bool PrefSet = false;
  double Pref;
  
  bool TrefSet = false;
  double Tref;
  
  bool rhorefSet = false;
  double rhoref;
  
  bool UrefSet = false;
  double Uref;

  bool MrefSet = false;
  double Mref;
  
  std::ostringstream errmsg;
  int error = 0;
  
  options_list::option_namelist li = $initialConditionsTGV.getOptionNameList();
  for(auto const & optName : li) {
    if(optName == "referencePosition") {
      std::ostringstream ss;
      std::vector<double> values;
      int err = getOptionValues(
        $initialConditionsTGV, optName, {"m", "m", "m"}, 1, 3, values, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        XrefSet = true;
        switch(values.size()) {
        case 1:
          Xref.x = values[0];
          Xref.y = 0.0;
          Xref.z = 0.0;
          break;
        case 2:
          Xref.x = values[0];
          Xref.y = values[1];
          Xref.z = 0.0;
          break;
        case 3:
          Xref.x = values[0];
          Xref.y = values[1];
          Xref.z = values[2];
          break;
        }
      }
    } else if(optName == "referenceLength") {
      std::ostringstream ss;
      std::vector<double> values;
      int err = getOptionValues(
        $initialConditionsTGV, optName, {"m", "m", "m"}, 1, 3, values, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        LrefSet = true;
        switch(values.size()) {
        case 1:
          Lref.x = values[0];
          Lref.y = 1.0;
          Lref.z = 1.0;
          break;
        case 2:
          Lref.x = values[0];
          Lref.y = values[1];
          Lref.z = 1.0;
          break;
        case 3:
          Lref.x = values[0];
          Lref.y = values[1];
          Lref.z = values[2];
          break;
        }
      }
    } else if(optName == "referenceMode") {
      std::ostringstream ss;
      std::vector<double> values;
      int err = getOptionValues(
        $initialConditionsTGV, optName, {"", "", ""}, 1, 3, values, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        KrefSet = true;
        switch(values.size()) {
        case 1:
          Kref.x = values[0];
          Kref.y = 1.0;
          Kref.z = 1.0;
          break;
        case 2:
          Kref.x = values[0];
          Kref.y = values[1];
          Kref.z = 1.0;
          break;
        case 3:
          Kref.x = values[0];
          Kref.y = values[1];
          Kref.z = values[2];
          break;
        }
      }
    } else if(optName == "referencePressure") {
      std::ostringstream ss;
      double value;
      int err = getOptionValue(
        $initialConditionsTGV, optName, "Pa", value, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        PrefSet = true;
        Pref = value;
      }
    } else if(optName == "referenceDensity") {
      std::ostringstream ss;
      double value;
      int err = getOptionValue(
        $initialConditionsTGV, optName, "kg/m/m/m", value, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        rhorefSet = true;
        rhoref = value;
      }
    } else if(optName == "referenceTemperature") {
      std::ostringstream ss;
      double value;
      int err = getOptionValue(
        $initialConditionsTGV, optName, "K", value, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        TrefSet = true;
        Tref = value;
      }
    } else if(optName == "referenceVelocity") {
      std::ostringstream ss;
      double value;
      int err = getOptionValue(
        $initialConditionsTGV, optName, "m/s", value, ss
      );
      
      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        UrefSet = true;
        Uref = value;
      }
    } else if(optName == "referenceMach") {
      std::ostringstream ss;
      double value;
      int err = getOptionValue(
        $initialConditionsTGV, optName, "", value, ss
      );

      if(err) {
        errmsg << "[Error parsing initialConditionsTGV::" << optName
          << " : " << ss.str() << "]";
        ++error;
      } else {
        MrefSet = true;
        Mref = value;
      }
    } else {
      errmsg << "[unknown option initialConditionsTGV::" << optName << "]";
      ++error;
    }
  }

  if(UrefSet == MrefSet) {
    errmsg << "[initialConditionsTGV requires either referenceVelocity or referenceMach]";
    ++error;
  }

  if(rhorefSet == TrefSet) {
    errmsg << "[initialConditionsTGV requires either referenceDensity or referenceTemperature]";
    ++error;
  }

  if(!XrefSet) {
    errmsg << "[initialConditionsTGV requires referencePosition]";
    ++error;
  }

  if(!LrefSet) {
    errmsg << "[initialConditionsTGV requires referenceLength]";
    ++error;
  }

  if(!KrefSet) {
    errmsg << "[initialConditionsTGV requires referenceMode]";
    ++error;
  }

  if(!PrefSet) {
    errmsg << "[initialConditionsTGV requires referencePressure]";
    ++error;
  }

  if(error) {
    $[Once] {
      LOG(ERROR) << errmsg.str();
    }
    Loci::Abort();
  } else {
    $tgvICParameters.Xref = Xref;
    $tgvICParameters.Lref = Lref;
    $tgvICParameters.Kref = Kref;
    $tgvICParameters.Pref = Pref;
    $tgvICParameters.rhoref = rhoref;
    $tgvICParameters.Tref = Tref;
    $tgvICParameters.Uref = Uref;
    $tgvICParameters.Mref = Mref;
    $tgvICParameters.rhorefSpecified = rhorefSet;
    $tgvICParameters.UrefSpecified = UrefSet;
  }
}

$rule pointwise(mixtureW_TGV_ic, mixtureR_TGV_ic <- speciesW, Runiv),
constraint(geom_cells, singleSpecies) {
  $mixtureW_TGV_ic = $speciesW[0];
  $mixtureR_TGV_ic = $Runiv/$speciesW[0];
}

$rule pointwise(mixtureCp_TGV_ic <- speciesCp_Constant),
constraint(geom_cells, caloricallyPerfectGas, singleSpecies) {
  $mixtureCp_TGV_ic = $speciesCp_Constant[0];
}

$rule pointwise(speciesY_TGV_ic <- tgvICParameters, Ns),
constraint(geom_cells, multiSpecies), prelude {
  $speciesY_TGV_ic.setVecSize(*$Ns);
} {
  // TODO: need to revisit this
  $speciesY_TGV_ic = mk_Scalar(0.0);
  $speciesY_TGV_ic[0] = 1.0;
}

$rule pointwise(mixtureW_TGV_ic, mixtureR_TGV_ic <- speciesY_TGV_ic, speciesW, Runiv, Ns),
constraint(geom_cells, multiSpecies) {
  $mixtureW_TGV_ic = mixture_mW_from_Y_sW($Ns, &$speciesY_TGV_ic[0], &$speciesW[0]);
  $mixtureR_TGV_ic = $Runiv/$mixtureW_TGV_ic;
}

$rule pointwise(mixtureCp_TGV_ic <- speciesY_TGV_ic, speciesCp_Constant, Ns),
constraint(geom_cells, caloricallyPerfectGas, multiSpecies) {
  $mixtureCp_TGV_ic = mixture_Cp_from_sCp_Y($Ns, &$speciesCp_Constant[0], &$speciesY_TGV_ic[0]);
}

$rule pointwise(
  gagePressure_TGV_ic, velocity_TGV_ic, temperature_TGV_ic
  <-
  mixtureCp_TGV_ic, mixtureR_TGV_ic, Pambient, cellcenter, tgvICParameters
), constraint(geom_cells, thermallyPerfectGas) {
  double const x = $cellcenter.x;
  double const y = $cellcenter.y;
  double const z = $cellcenter.z;

  double const x0 = $tgvICParameters.Xref.x;
  double const y0 = $tgvICParameters.Xref.y;
  double const z0 = $tgvICParameters.Xref.z;

  double const Lx = $tgvICParameters.Lref.x;
  double const Ly = $tgvICParameters.Lref.y;
  double const Lz = $tgvICParameters.Lref.z;

  double const Kx = $tgvICParameters.Kref.x;
  double const Ky = $tgvICParameters.Kref.y;
  double const Kz = $tgvICParameters.Kref.z;

  double const P0 = $tgvICParameters.Pref;

  double rho0, T0, U0, a0, M0;

  if($tgvICParameters.rhorefSpecified) {
    rho0 = $tgvICParameters.rhoref;
    T0 = eos_TP_T_from_r_P_R(rho0, P0, $mixtureR_TGV_ic);
  } else {
    T0 = $tgvICParameters.Tref;
    rho0 = eos_TP_r_from_P_T_R(P0, T0, $mixtureR_TGV_ic);
  }

  if($tgvICParameters.UrefSpecified) {
    U0 = $tgvICParameters.Uref;
    a0 = eos_TP_a_from_Cp_R_T($mixtureCp_TGV_ic, $mixtureR_TGV_ic, T0);
    M0 = U0/a0;
  } else {
    a0 = eos_TP_a_from_Cp_R_T($mixtureCp_TGV_ic, $mixtureR_TGV_ic, T0);
    U0 = $tgvICParameters.Mref*a0;
    M0 = $tgvICParameters.Mref;
  }

  double const U02 = U0*U0;

  double const P = P0 + 0.0625*rho0*U02*(
    cos(2.0*Kx*(x-x0)/Lx) + cos(2.0*Ky*(y-y0)/Ly)
  )*(2.0 + cos(2.0*Kz*(z-z0)/Lz));

  $gagePressure_TGV_ic = P - $Pambient;

  if($tgvICParameters.rhorefSpecified) {
    $temperature_TGV_ic = eos_TP_T_from_r_P_R(rho0, P, $mixtureR_TGV_ic);
  } else {
    $temperature_TGV_ic = T0;
  }

  $velocity_TGV_ic = Loci::vector3d<double>(
     U0*sin(Kx*(x-x0)/Lx)*cos(Ky*(y-y0)/Ly)*cos(Kz*(z-z0)/Lz),
    -U0*cos(Kx*(x-x0)/Lx)*sin(Ky*(y-y0)/Ly)*cos(Kz*(z-z0)/Lz),
    0.0
  );
}

// -----------------------------------------------------------------------------

$rule apply(gagePressure_ic <- gagePressure_TGV_ic)[Loci::Summation],
constraint(geom_cells, withoutICDirectory) {
  join($gagePressure_ic, $gagePressure_TGV_ic);
}

$rule apply(velocity_ic <- velocity_TGV_ic)[Loci::Summation],
constraint(geom_cells, withoutICDirectory) {
  join($velocity_ic, $velocity_TGV_ic);
}

$rule apply(temperature_ic <- temperature_TGV_ic)[Loci::Summation],
constraint(geom_cells, withoutICDirectory) {
  join($temperature_ic, $temperature_TGV_ic);
}

$rule apply(speciesY_ic <- speciesY_TGV_ic)[Loci::Summation],
constraint(geom_cells, withoutICDirectory) {
  join($speciesY_ic, $speciesY_TGV_ic);
}

// =============================================================================

$rule unit(timeStep_ic), constraint(UNIVERSE) {
  $timeStep_ic = 0;
}

$rule apply(timeStep_ic <- timeStepSize)[Loci::Maximum], prelude {
};

$rule unit(stime_ic), constraint(UNIVERSE) {
  $stime_ic = 0.0;
}

$rule apply(stime_ic <- timeStepSize)[Loci::Maximum], prelude {
};

// =============================================================================
// Load the initial conditions from file
// =============================================================================

class TimeStepFromFile : public singleton_rule {
  const_param<std::string> icDirectory, caseName;
  param<double> stime;
  param<int> timeStep;
  
public:
  TimeStepFromFile();
  virtual void compute(sequence const & seq);
};

TimeStepFromFile::TimeStepFromFile() {
  name_store("icDirectory", icDirectory);
  name_store("caseName", caseName);
  name_store("stime_icf", stime);
  name_store("timeStep_icf", timeStep);
  input("icDirectory,caseName");
  output("stime_icf,timeStep_icf");
  disable_threading();
}

void TimeStepFromFile::compute(sequence const & seq) {
  if(Loci::GLOBAL_AND(seq == EMPTY)) {
    return;
  }
  
  std::string filename = *icDirectory + "flowVars_" + *caseName;
  
  hid_t fileId = Loci::hdf5OpenFile(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
  Loci::entitySet dom = ~EMPTY;
  *stime = 0.0;
  *timeStep = 0;
  Loci::readContainer(fileId, "stime", stime.Rep(), dom);
  Loci::readContainer(fileId, "timeStep", timeStep.Rep(), dom);
  Loci::hdf5CloseFile(fileId);
}

Loci::register_rule<TimeStepFromFile> registerTimeStepFromFile;

$rule apply(timeStep_ic <- timeStep_icf)[Loci::Maximum] {
  join($timeStep_ic, $timeStep_icf);
}

$rule apply(stime_ic <- stime_icf)[Loci::Maximum] {
  join($stime_ic, $stime_icf);
}

$rule pointwise(
  gagePressure_icf, velocity_icf, temperature_icf
  <-
  icDirectory, caseName, Pambient
), constraint(geom_cells, singleSpecies, withICDirectory),
option(disable_threading), prelude {
  std::string filename = *$icDirectory + "flowVars_" + *$caseName;
  
  $[Once] {
    LOG(INFO) << "Reading flow variables from " << filename;
  }
  
  struct stat buf;
  int has_file = 0;
  $[Once] {
    if(stat(filename.c_str(), &buf) == 0) {
      if(buf.st_size != 0 && S_ISREG(buf.st_mode)) {
        has_file = 1;
      } else {
        has_file = 2;
      }
    }
  }
  
  MPI_Bcast(&has_file, 1, MPI_INT, 0, MPI_COMM_WORLD);
  if(has_file == 2) {
    $[Once] {
      LOG(ERROR) << "Unable to find file '" << filename << "'";
    }
    Loci::Abort();
  }
  
  hid_t fileId = Loci::hdf5OpenFile(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
  
  Loci::entitySet readSet = entitySet(seq);
  Loci::readContainer(fileId, "gagePressure", $gagePressure_icf.Rep(), readSet);
  Loci::readContainer(fileId, "velocity", $velocity_icf.Rep(), readSet);
  Loci::readContainer(fileId, "temperature", $temperature_icf.Rep(), readSet);
  param<double> Pref;
  Loci::readContainer(fileId, "Pambient", Pref.Rep(), readSet);
  double dp = *Pref-*$Pambient;
  FORALL(readSet, ii) {
    $gagePressure_icf[ii] += dp;
  } ENDFORALL;
  Loci::hdf5CloseFile(fileId);
};

$rule pointwise(
  gagePressure_icf, velocity_icf, temperature_icf, speciesY_icf
  <-
  icDirectory, caseName, Pambient, Ns
), constraint(geom_cells, multiSpecies, withICDirectory),
option(disable_threading), prelude {
  $speciesY_icf.setVecSize(*$Ns);
  
  std::string filename = *$icDirectory + "flowVars_" + *$caseName;
  
  $[Once] {
    LOG(INFO) << "Reading flow variables from " << filename;
  }
  
  struct stat buf;
  int has_file = 0;
  $[Once] {
    if(stat(filename.c_str(), &buf) == 0) {
      if(buf.st_size != 0 && S_ISREG(buf.st_mode)) {
        has_file = 1;
      } else {
        has_file = 2;
      }
    }
  }
  
  MPI_Bcast(&has_file, 1, MPI_INT, 0, MPI_COMM_WORLD);
  if(has_file == 2) {
    $[Once] {
      LOG(ERROR) << "Unable to find file '" << filename << "'";
    }
    Loci::Abort();
  }
  
  hid_t fileId = Loci::hdf5OpenFile(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
  
  Loci::entitySet readSet = entitySet(seq);
  Loci::readContainer(fileId, "gagePressure", $gagePressure_icf.Rep(), readSet);
  Loci::readContainer(fileId, "velocity", $velocity_icf.Rep(), readSet);
  Loci::readContainer(fileId, "temperature", $temperature_icf.Rep(), readSet);
  Loci::readContainer(fileId, "speciesY", $speciesY_icf.Rep(), readSet);
  param<double> Pref;
  Loci::readContainer(fileId, "Pambient", Pref.Rep(), readSet);
  double dp = *Pref-*$Pambient;
  FORALL(readSet, ii) {
    $gagePressure_icf[ii] += dp;
  } ENDFORALL;
  Loci::hdf5CloseFile(fileId);
};

// -----------------------------------------------------------------------------

$rule apply(gagePressure_ic <- gagePressure_icf)[Loci::Summation],
constraint(geom_cells, withICDirectory) {
  join($gagePressure_ic, $gagePressure_icf);
}

$rule apply(velocity_ic <- velocity_icf)[Loci::Summation],
constraint(geom_cells, withICDirectory) {
  join($velocity_ic, $velocity_icf);
}

$rule apply(temperature_ic <- temperature_icf)[Loci::Summation],
constraint(geom_cells, withICDirectory) {
  join($temperature_ic, $temperature_icf);
}

$rule apply(speciesY_ic <- speciesY_icf)[Loci::Summation],
constraint(geom_cells, withICDirectory, multiSpecies) {
  join($speciesY_ic, $speciesY_icf);
}

// =============================================================================
// Calculate initial conditions of derived quantities from the
// primitive variable initial conditions.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Calculations for single-species.

$rule pointwise(mixtureW_ic <- speciesW),
constraint(geom_cells, singleSpecies) {
  $mixtureW_ic = $speciesW[0];
}

$rule pointwise(mixtureCp_ic, mixtureEnthalpy_ic <- temperature_ic, speciesCp_Constant),
constraint(geom_cells, singleSpecies, caloricallyPerfectGas) {
  $mixtureCp_ic = $speciesCp_Constant[0];
  $mixtureEnthalpy_ic = $speciesCp_Constant[0]*$temperature_ic;
}

// -----------------------------------------------------------------------------
// Calculations for multi-species.

$rule pointwise(mixtureW_ic <- speciesY_ic, speciesW, Ns),
constraint(geom_cells, multiSpecies) {
  $mixtureW_ic = mixture_mW_from_Y_sW($Ns, &$speciesY_ic[0], &$speciesW[0]);
}

$rule pointwise(speciesX_ic <- speciesY_ic, mixtureW_ic, speciesW, Ns),
constraint(geom_cells, multiSpecies), prelude {
  $speciesX_ic.setVecSize(*$Ns);
} {
  mixture_X_from_Y_sW_mW(
    $Ns, &$speciesX_ic[0], &$speciesY_ic[0], &$speciesW[0], $mixtureW_ic
  );
}

$rule pointwise(
  speciesCp_ic, speciesEnthalpy_ic
  <-
  temperature_ic, speciesCp_Constant, Ns
), constraint(geom_cells, multiSpecies, caloricallyPerfectGas), prelude {
  $speciesCp_ic.setVecSize(*$Ns);
  $speciesEnthalpy_ic.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $speciesCp_ic[i] = $speciesCp_Constant[i];
    $speciesEnthalpy_ic[i] = $speciesCp_Constant[i]*$temperature_ic;
  }
}

$rule pointwise(
  mixtureCp_ic, mixtureEnthalpy_ic
  <-
  speciesY_ic, speciesCp_ic, speciesEnthalpy_ic, Ns
), constraint(geom_cells, multiSpecies, caloricallyPerfectGas) {
  $mixtureCp_ic = mixture_Cp_from_sCp_Y(
    $Ns, &$speciesCp_ic[0], &$speciesY_ic[0]
  );
  $mixtureEnthalpy_ic = mixture_H_from_sH_Y(
    $Ns, &$speciesEnthalpy_ic[0], &$speciesY_ic[0]
  );
}

// -----------------------------------------------------------------------------
// Calculations common to both the single-species and multi-species.

$rule pointwise(density_ic <- gagePressure_ic, temperature_ic, mixtureR_ic, Pambient),
constraint(geom_cells, thermallyPerfectGas) {
  $density_ic = eos_TP_r_from_P_T_R($gagePressure_ic+$Pambient, $temperature_ic, $mixtureR_ic);
}

$rule pointwise(mixtureR_ic <- mixtureW_ic, Runiv),
constraint(geom_cells) {
  $mixtureR_ic = $Runiv/$mixtureW_ic;
}

// =============================================================================

} // end: namespace flame
