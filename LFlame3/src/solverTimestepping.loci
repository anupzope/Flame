#include <flame.hh>
#include <plot.hh>

$include "flame.lh"
$include "FVM.lh"

#include <glog/logging.h>

namespace flame {

// =============================================================================
// Default values for parameters that control the time loop.
// =============================================================================

$rule default(nTimeSteps) {
  $nTimeSteps = 10;
}

$rule default(timeStepSize) {
  $timeStepSize = 1e-5;
}

$rule default(timeIntegrationMethod) {
  $timeIntegrationMethod = "rk";
}

// =============================================================================
// Calculation of constraints that define time integration scheme.
// =============================================================================

$rule constraint(timeIntegrationRK <- timeIntegrationMethod) {
  $timeIntegrationRK = EMPTY;
  if($timeIntegrationMethod == "rk") {
    $timeIntegrationRK = ~EMPTY;
  } else {
    $[Once] {
      LOG(ERROR) << "unknown timeIntegrationMethod " << $timeIntegrationMethod;
    }
    Loci::Abort();
  }
}

// =============================================================================
// Set unit values for single-species source term.
// =============================================================================

$rule unit(ssResidual), constraint(geom_cells, singleSpecies) {
  $ssResidual[0] = 0.0;
  $ssResidual[1] = 0.0;
  $ssResidual[2] = 0.0;
  $ssResidual[3] = 0.0;
  $ssResidual[4] = 0.0;
}

// =============================================================================
// Set unit values for multi-species source term.
// =============================================================================

$rule unit(msResidual <- Ns), constraint(geom_cells, multiSpecies), prelude {
  $msResidual.setVecSize(*$Ns+4);
} {
  $msResidual = mk_Scalar(0.0);
}

// =============================================================================
// Integrate single-species convective and diffusive flux over faces of a cell
// to compute contribution to the source term at a cell.
// =============================================================================

// Add convetive contribution from a face to its left cell.
$rule apply((cl,cr)->ssResidual <- ssConvectiveFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, singleSpecies) {
  for(int i = 0; i < 5; ++i) {
    $cl->$ssResidual[i] -= $ssConvectiveFlux_f[i];
    $cr->$ssResidual[i] += $ssConvectiveFlux_f[i];
  }
}

// Add convective contribution from a face to its right cell.
$rule apply(cl->ssResidual <- ssConvectiveFlux_f)[Loci::Summation],
constraint(boundary_faces, singleSpecies) {
  for(int i = 0; i < 5; ++i) {
    $cl->$ssResidual[i] -= $ssConvectiveFlux_f[i];
  }
}

// Add diffusive contribution from a face to its left cell.
$rule apply((cl,cr)->ssResidual <- viscousFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, singleSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$ssResidual[i] += $viscousFlux_f[i];
    $cr->$ssResidual[i] -= $viscousFlux_f[i];
  }
}

// Add diffusive contribution from a face to its right cell.
$rule apply(cl->ssResidual <- viscousFlux_f)[Loci::Summation],
constraint(boundary_faces, singleSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$ssResidual[i] += $viscousFlux_f[i];
  }
}

// =============================================================================
// Integrate multi-species convective and diffusive flux over faces of a cell to
// compute contribution to the source term at a cell.
// =============================================================================

// Add convective contribution from a face to its left cell.
$rule apply((cl,cr)->msResidual <- msConvectiveFlux_f, Ns)[Loci::Summation],
constraint((cl,cr)->geom_cells, multiSpecies) {
  for(int i = 0; i < $Ns+4; ++i) {
    $cl->$msResidual[i] -= $msConvectiveFlux_f[i];
    $cr->$msResidual[i] += $msConvectiveFlux_f[i];
  }
}

// Add convective contribution from a face to its right cell.
$rule apply(cl->msResidual <- msConvectiveFlux_f, Ns)[Loci::Summation],
constraint(boundary_faces, multiSpecies) {
  for(int i = 0; i < $Ns+4; ++i) {
    $cl->$msResidual[i] -= $msConvectiveFlux_f[i];
  }
}

// Add diffusive contribution from a face to its left cell.
$rule apply((cl,cr)->msResidual <- viscousFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, multiSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$msResidual[i] += $viscousFlux_f[i];
    $cr->$msResidual[i] -= $viscousFlux_f[i];
  }
}

// Add diffusive contribution from a face to its right cell.
$rule apply(cl->msResidual <- viscousFlux_f, Ns)[Loci::Summation],
constraint(boundary_faces, multiSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$msResidual[i] += $viscousFlux_f[i];
  }
}

// =============================================================================
// Time loop initialization.
// =============================================================================

$rule singleton(timeStep{n=0} <- timeStep_ic) {
  $timeStep{n=0} = $timeStep_ic;
}

$rule singleton(stime{n=0} <- stime_ic) {
  $stime{n=0} = $stime_ic;
}

$rule pointwise(gagePressure{n=0} <- gagePressure_ic) {
  $gagePressure{n=0} = $gagePressure_ic;
}

$rule pointwise(temperature{n=0} <- temperature_ic) {
  $temperature{n=0} = $temperature_ic;
}

$rule pointwise(velocity{n=0} <- velocity_ic) {
  $velocity{n=0} = $velocity_ic;
}

$rule pointwise(speciesY{n=0} <- speciesY_ic, Ns), prelude {
  $speciesY{n=0}.setVecSize(*$Ns);
} {
  $speciesY{n=0} = $speciesY_ic;
}

$rule pointwise(mixtureW{n} <- speciesY{n}, speciesW, Ns),
constraint(geom_cells) {
  double rW = 0.0;
  for(int i = 0; i < $Ns; ++i) {
    rW += $speciesY{n}[i]/$speciesW[i];
  }
  $mixtureW{n} = 1.0/rW;
}

$rule pointwise(mixtureR{n} <- mixtureW{n}, Runiv),
constraint(geom_cells) {
  $mixtureR{n} = $Runiv/$mixtureW{n};
}

$rule pointwise(speciesX{n} <- speciesY{n}, mixtureW{n}, speciesW, Ns),
constraint(geom_cells), prelude {
  $speciesX{n}.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $speciesX{n}[i] = $speciesY{n}[i]*$mixtureW{n}/$speciesW[i];
  }
}

$rule pointwise(mixtureCp{n} <- speciesY{n}, speciesConstantCp, Ns),
constraint(geom_cells, multiSpecies, caloricallyPerfectGas) {
  double Cp = 0.0;
  for(int i = 0; i < $Ns; ++i) {
    Cp += $speciesY{n}[i]*$speciesConstantCp[i];
  }
  $mixtureCp{n} = Cp;
}

//$rule pointwise(speciesX{n=0} <- speciesY_ic, speciesW, mixtureW{n=0}, Ns),
//constraint(geom_cells), prelude {
//  $speciesX{n=0}.setVecSize(*$Ns);
//} {
//  for(int i = 0; i < $Ns; ++i) {
//    $speciesX{n=0}[i] = $speciesY_ic[i]*$mixtureW{n=0}/$speciesW[i];
//  }
//}
//
//$rule pointwise(mixtureW{n=0} <- speciesY_ic, speciesW, Ns), constraint(geom_cells) {
//  double rW = 0.0;
//  for(int i = 0; i < $Ns; ++i) {
//    rW += $speciesY_ic[i]/$speciesW[i];
//  }
//  $mixtureW{n=0} = 1.0/rW;
//}
//
//$rule pointwise(mixtureR{n=0} <- Runiv, mixtureW{n=0}), constraint(geom_cells) {
//  $mixtureR{n=0} = $Runiv/$mixtureW{n=0};
//}
//
//$rule pointwise(mixtureCp{n=0} <- speciesY_ic, speciesConstantCp, Ns),
//constraint(geom_cells, multiSpecies, caloricallyPerfectGas) {
//  double Cp = 0.0;
//  for(int i = 0; i < $Ns; ++i) {
//    Cp += $speciesY_ic[i]*$speciesConstantCp[i];
//  }
//  $mixtureCp{n=0} = Cp;
//}

//$rule pointwise(
//  speciesX{n=0}, mixtureW{n=0}, mixtureR{n=0}, mixtureCp{n=0}
//  <-
//  speciesY_ic, speciesW, speciesConstantCp, Runiv, Ns
//), constraint(multiSpecies, caloricallyPerfectGas, geom_cells), prelude {
//  $speciesX{n=0}.setVecSize(*$Ns);
//} {
//  double rW = 0.0;
//  double R = 0.0;
//  double Cp = 0.0;
//  for(int i = 0; i < $Ns; ++i) {
//    rW += $speciesY_ic[i]/$speciesW[i];
//    Cp += $speciesY_ic[i]*$speciesConstantCp[i];
//  }
//  R = $Runiv*rW;
//  double W = 1.0/rW;
//  
//  for(int i = 0; i < $Ns; ++i) {
//    $speciesX{n=0}[i] = $speciesY_ic[i]*W/$speciesW[i];
//  }
//  $mixtureW{n=0} = W;
//  $mixtureR{n=0} = R;
//  $mixtureCp{n=0} = Cp;
//}

//$rule pointwise(mixtureW{n=0} <- mixtureY_ic, Ns), prelude {
//  $mixtureW{n=0}.setVecSize(*$Ns);
//} {
//  $mixtureW{n=0} = $mixtureW_ic;
//}
//
//$rule pointwise(mixtureR{n=0} <- mixtureR_ic) {
//  $mixtureR{n=0} = $mixtureR_ic;
//}
//
//$rule pointwise(mixtureCp{n=0} <- mixtureCp_ic) {
//  $mixtureCp{n=0} = $mixtureCp_ic;
//}

//$rule pointwise(
//  speciesY{n=0}, mixtureW{n=0}, mixtureR{n=0}, mixtureGamma{n=0}
//  <-
//  speciesY_ic, speciesW, speciesGamma, Runiv, Ns
//), constraint(multiSpecies), prelude {
//  $speciesY{n=0}.setVecSize(*$Ns);
//} {
//  double W = 0.0;
//  double R = 0.0;
//  double gamma = 0.0;
//  for(int i = 0; i < $Ns; ++i) {
//    W += $speciesY_ic[i]/$speciesW[i];
//    gamma += $speciesY_ic[i]/($speciesGamma[i]-1.0);
//  }
//  R = $Runiv*W;
//  W = 1.0/W;
//  gamma = 1.0/gamma + 1.0;
//  
//  $speciesY{n=0} = $speciesY_ic;
//  $mixtureW{n=0} = W;
//  $mixtureR{n=0} = R;
//  $mixtureGamma{n=0} = gamma;
//}

//$rule pointwise(
//  mixtureCp{n=0}, mixtureEnthalpy{n=0}
//  <-
//  mixtureR{n=0}, mixtureGamma{n=0}, temperature{n=0},
//  speciesY_ic, speciesW, speciesGamma, Ns
//), constraint(multiSpecies, idealGas) {
//  double const cp = $mixtureGamma{n=0}*$mixtureR{n=0}/($mixtureGamma{n=0}-1.0);
//  double const h = cp*$temperature{n=0};
//  
//  $mixtureCp{n=0} = cp;
//  $mixtureEnthalpy{n=0} = h;
//}

// =============================================================================
// Time loop advance: These are specific to the time integration scheme. Hence,
// they are written in files specific to the scheme.
// =============================================================================


// =============================================================================
// Time loop collapse.
// =============================================================================

$rule singleton(timeStepFinished{n} <- $n{n}, timeStep{n}, nTimeSteps) {
  $timeStepFinished{n} = $$n{n} >= $nTimeSteps; //$timeStep{n} == $nTimeSteps;
}

$rule pointwise(solution <- gagePressure{n}, velocity{n}, temperature{n}),
constraint(geom_cells{n}, singleSpecies),
conditional(timeStepFinished{n}),
inplace(solution|gagePressure{n}), prelude {};

$rule pointwise(solution <- gagePressure{n}, velocity{n}, temperature{n},
speciesY{n}), constraint(geom_cells{n}, multiSpecies),
conditional(timeStepFinished{n}),
inplace(solution|gagePressure{n}), prelude {};

// =============================================================================

} // end: namespace flame