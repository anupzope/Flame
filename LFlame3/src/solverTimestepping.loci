$include "flame.lh"
$include "FVM.lh"

#include <logger.hh>
#include <plot.hh>

#include <Loci.h>

//==============================================================================

$rule default(nTimeSteps) {
  $nTimeSteps = 10;
}

$rule default(timeStepSize) {
  $timeStepSize = 1e-5;
}

$rule default(timeIntegrationMethod) {
  $timeIntegrationMethod = "rk2";
}

//==============================================================================

$rule constraint(timeIntegrationRK2 <- timeIntegrationMethod) {
  $timeIntegrationRK2 = EMPTY;
  if($timeIntegrationMethod == "rk2") {
    $timeIntegrationRK2 = ~EMPTY;
  } else {
    $[Once] {
      flame::logger.severe("unknown timeIntegrationMethod ", $timeIntegrationMethod);
    }
    Loci::Abort();
  }
}

//==============================================================================

$rule unit(massConvection_f <- Ns), constraint(area), prelude {
  $massConvection_f.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $massConvection_f[i] = 0.0;
  }
}

$rule unit(momentumConvection_f), constraint(area) {
  $momentumConvection_f = Loci::vector3d<double>(0.0, 0.0, 0.0);
}

$rule unit(energyConvection_f), constraint(area) {
  $energyConvection_f = 0.0;
}

$rule apply(massConvection_f <- Ns, leftvM(massFractions), rightvM(massFractions))[Loci::Summation] {
  for(int i = 0; i < $Ns; ++i) {
    $massConvection_f[i] = $leftvM(massFractions)[i] + $rightvM(massFractions)[i];
  }
}

//==============================================================================

$rule unit(massDiffusion_f <- Ns), constraint(area), prelude {
  $massDiffusion_f.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $massDiffusion_f[i] = 0.0;
  }
}

$rule unit(momentumDiffusion_f), constraint(area) {
  $momentumDiffusion_f = Loci::vector3d<double>(0.0, 0.0, 0.0);
}

$rule unit(energyDiffusion_f), constraint(area) {
  $energyDiffusion_f = 0.0;
}

//==============================================================================

$rule unit(srcMass <- Ns), constraint(geom_cells), prelude {
  $srcMass.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $srcMass[i] = 0.0;
  }
}

$rule apply(cl->srcMass <- massConvection_f, massDiffusion_f, Ns)[Loci::Summation],
constraint(cl->geom_cells) {
  for(int i = 0; i < $Ns; ++i) {
    $cl->$srcMass[i] -= $massConvection_f[i] - $massDiffusion_f[i];
  }
}

$rule apply(cr->srcMass <- massConvection_f, massDiffusion_f, Ns)[Loci::Summation],
constraint(cr->geom_cells) {
  for(int i = 0; i < $Ns; ++i) {
    $cr->$srcMass[i] += $massConvection_f[i] - $massDiffusion_f[i];
  }
}

$rule unit(srcMomentum), constraint(geom_cells) {
  $srcMomentum = Loci::vector3d(0.0, 0.0, 0.0);
}

$rule apply(cl->srcMomentum <- momentumConvection_f, momentumDiffusion_f)[Loci::Summation],
constraint(cl->geom_cells) {
  $cl->$srcMomentum -= $momentumConvection_f - $momentumDiffusion_f;
}

$rule apply(cr->srcMomentum <- momentumConvection_f, momentumDiffusion_f)[Loci::Summation],
constraint(cr->geom_cells) {
  $cr->$srcMomentum += $momentumConvection_f - $momentumDiffusion_f;
}

$rule unit(srcEnergy), constraint(geom_cells) {
  $srcEnergy = 0.0;
}

$rule apply(cl->srcEnergy <- energyConvection_f, energyDiffusion_f)[Loci::Summation],
constraint(cl->geom_cells) {
  $cl->$srcEnergy -= $energyConvection_f - $energyDiffusion_f;
}

$rule apply(cr->srcEnergy <- energyConvection_f, energyDiffusion_f)[Loci::Summation],
constraint(cr->geom_cells) {
  $cr->$srcEnergy += $energyConvection_f - $energyDiffusion_f;
}

//==============================================================================

$rule pointwise(gagePressure{n=0} <- gagePressure_ic) {
  $gagePressure{n=0} = $gagePressure_ic;
}

$rule pointwise(temperature{n=0} <- temperature_ic) {
  $temperature{n=0} = $temperature_ic;
}

$rule pointwise(velocity{n=0} <- velocity_ic) {
  $velocity{n=0} = $velocity_ic;
}

$rule pointwise(massFractions{n=0} <- massFractions_ic, Ns), prelude {
  $massFractions{n=0}.setVecSize(*$Ns);
} {
  $massFractions{n=0} = $massFractions_ic;
}

$rule singleton(timeStep{n=0} <- timeStep_ic) {
  $timeStep{n=0} = $timeStep_ic;
}

$rule singleton(stime{n=0} <- stime_ic) {
  $stime{n=0} <- $stime_ic;
}

//==============================================================================

$rule singleton(timeStepFinished{n} <- timeStep{n}, nTimeSteps) {
  $timeStepFinished{n} = $timeStep{n} == $nTimeSteps;
}

$rule pointwise(solution <- gagePressure{n}, velocity{n},
temperature{n}, massFractions{n}), constraint(geom_cells{n}),
conditional(timeStepFinished{n}),
inplace(solution|gagePressure{n}), prelude {};

//==============================================================================

$rule singleton(doPlot{n}, plotPostfix{n} <- timeStep{n}, plotSettings) {
  $doPlot{n} = false;
  
  std::string postfix;
  
  if($plotSettings.frequency > 0) {
    int const nLevels = $plotSettings.counts.size();
    int const f = $plotSettings.frequency;
    int k = 1;
    for(int i = 0; i < nLevels; ++i) {
      int c = $plotSettings.counts[i];
      if(c > 0) {
        if(($timeStep{n} % (k*f)) == 0) {
          $doPlot{n} = true;
          std::stringstream ss;
          ss << ($timeStep{n}/(k*f))%c << "L" << i;
          $plotPostfix{n} = ss.str();
        }
      }
      k *= c;
    }
  }
}

//==============================================================================
