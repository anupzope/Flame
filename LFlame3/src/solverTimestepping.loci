#include <flame.hh>
#include <plot.hh>

$include "flame.lh"
$include "FVM.lh"

#define GLOG_USE_GLOG_EXPORT
#include <glog/logging.h>

namespace flame {

// =============================================================================
// Default values for parameters that control the time loop.
// =============================================================================

$rule default(nTimeSteps) {
  $nTimeSteps = 10;
}

$rule default(timeStepSize) {
  $timeStepSize = 1e-5;
}

$rule default(timeIntegrationMethod) {
  $timeIntegrationMethod = "rk";
}

// =============================================================================
// Calculation of constraints that define time integration scheme.
// =============================================================================

$rule constraint(timeIntegrationRK <- timeIntegrationMethod) {
  $timeIntegrationRK = EMPTY;
  if($timeIntegrationMethod == "rk") {
    $timeIntegrationRK = ~EMPTY;
  } else {
    $[Once] {
      LOG(ERROR) << "unknown timeIntegrationMethod " << $timeIntegrationMethod;
    }
    Loci::Abort();
  }
}

// =============================================================================
// Set unit values for single-species source term.
// =============================================================================

$rule unit(ssResidual), constraint(geom_cells, singleSpecies) {
  $ssResidual[0] = 0.0;
  $ssResidual[1] = 0.0;
  $ssResidual[2] = 0.0;
  $ssResidual[3] = 0.0;
  $ssResidual[4] = 0.0;
}

// =============================================================================
// Set unit values for multi-species source term.
// =============================================================================

$rule unit(msResidual <- Ns), constraint(geom_cells, multiSpecies), prelude {
  $msResidual.setVecSize(*$Ns+4);
} {
  $msResidual = mk_Scalar(0.0);
}

// =============================================================================
// Integrate single-species convective and diffusive flux over faces of a cell
// to compute contribution to the source term at a cell.
// =============================================================================

// Add convetive contribution from internal faces to left and right
// cells.
$rule apply((cl,cr)->ssResidual <- ssConvectiveFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, singleSpecies) {
  for(int i = 0; i < 5; ++i) {
    $cl->$ssResidual[i] -= $ssConvectiveFlux_f[i];
    $cr->$ssResidual[i] += $ssConvectiveFlux_f[i];
  }
}

// Add convective contribution from boundary faces to left cells.
$rule apply(cl->ssResidual <- ssConvectiveFlux_f)[Loci::Summation],
constraint(boundary_faces, singleSpecies) {
  for(int i = 0; i < 5; ++i) {
    $cl->$ssResidual[i] -= $ssConvectiveFlux_f[i];
  }
}

// Add diffusive contribution from internal faces to left and right
// cells.
$rule apply((cl,cr)->ssResidual <- viscousFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, singleSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$ssResidual[i] += $viscousFlux_f[i];
    $cr->$ssResidual[i] -= $viscousFlux_f[i];
  }
}

// Add diffusive contribution from boundary faces to left cells.
$rule apply(cl->ssResidual <- viscousFlux_f)[Loci::Summation],
constraint(boundary_faces, singleSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$ssResidual[i] += $viscousFlux_f[i];
  }
}

// =============================================================================
// Integrate multi-species convective and diffusive flux over faces of a cell to
// compute contribution to the source term at a cell.
// =============================================================================

// Add convective contribution from internal faces to left and right
// cells.
$rule apply((cl,cr)->msResidual <- msConvectiveFlux_f, Ns)[Loci::Summation],
constraint((cl,cr)->geom_cells, multiSpecies) {
  for(int i = 0; i < $Ns+4; ++i) {
    $cl->$msResidual[i] -= $msConvectiveFlux_f[i];
    $cr->$msResidual[i] += $msConvectiveFlux_f[i];
  }
}

// Add convective contribution from boundary faces to left cells.
$rule apply(cl->msResidual <- msConvectiveFlux_f, Ns)[Loci::Summation],
constraint(boundary_faces, multiSpecies) {
  for(int i = 0; i < $Ns+4; ++i) {
    $cl->$msResidual[i] -= $msConvectiveFlux_f[i];
  }
}

// Add viscous contribution from internal faces to left and right
// cells.
$rule apply((cl,cr)->msResidual <- viscousFlux_f)[Loci::Summation],
constraint((cl,cr)->geom_cells, multiSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$msResidual[i] += $viscousFlux_f[i];
    $cr->$msResidual[i] -= $viscousFlux_f[i];
  }
}

// Add viscous contribution from boundary faces to left cells.
$rule apply(cl->msResidual <- viscousFlux_f, Ns)[Loci::Summation],
constraint(boundary_faces, multiSpecies, viscousFlow) {
  for(int i = 0; i < 4; ++i) {
    $cl->$msResidual[i] += $viscousFlux_f[i];
  }
}

  // Add diffusive contribution from internal faces to left and right
// cells.
$rule apply((cl,cr)->msResidual <- msDiffusiveFlux_f, Ns)[Loci::Summation],
  constraint((cl,cr)->geom_cells, multiSpecies, speciesMassDiffusionEnabled) {
    for(int i = 5; i < $Ns+4; ++i) {
      $cl->$msResidual[i] += $msDiffusiveFlux_f[i-5];
      $cr->$msResidual[i] -= $msDiffusiveFlux_f[i-5];
    }
}

  // Add diffusive contribution from boundary faces to left cells.
$rule apply(cl->msResidual <- msDiffusiveFlux_f, Ns)[Loci::Summation],
  constraint(boundary_faces, multiSpecies, speciesMassDiffusionEnabled) {
    for(int i = 5; i < $Ns+4; ++i) {
      $cl->$msResidual[i] += $msDiffusiveFlux_f[i-5];
    }
}

// =============================================================================
// Time loop initialization.
// =============================================================================

$rule singleton(timeStep{n=0} <- timeStep_ic) {
  $timeStep{n=0} = $timeStep_ic;
}

$rule singleton(stime{n=0} <- stime_ic) {
  $stime{n=0} = $stime_ic;
}

$rule pointwise(gagePressure{n=0} <- gagePressure_ic) {
  $gagePressure{n=0} = $gagePressure_ic;
}

$rule pointwise(temperature{n=0} <- temperature_ic) {
  $temperature{n=0} = $temperature_ic;
}

$rule pointwise(velocity{n=0} <- velocity_ic) {
  $velocity{n=0} = $velocity_ic;
}

$rule pointwise(speciesY{n=0} <- speciesY_ic, Ns), prelude {
  $speciesY{n=0}.setVecSize(*$Ns);
} {
  $speciesY{n=0} = $speciesY_ic;
}

// =============================================================================
// Calculation of time-step specific variables.
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Single-species calculations.
// -----------------------------------------------------------------------------

// Calculation of mixture molecular weight.
$rule pointwise(mixtureW{n} <- speciesW, Ns),
  constraint(singleSpecies, geom_cells) {
  $mixtureW{n} = $speciesW[0];
}

// Calculation of mixture specific heat.
$rule pointwise(mixtureCp{n} <- speciesCp_Constant),
constraint(singleSpecies, caloricallyPerfectGas, geom_cells) {
  $mixtureCp{n} = $speciesCp_Constant[0];
}

// Calculation of mixture enthalpy.
$rule pointwise(mixtureEnthalpy{n} <- temperature{n}, speciesCp_Constant),
constraint(singleSpecies, caloricallyPerfectGas, geom_cells) {
  $mixtureEnthalpy{n} = $speciesCp_Constant[0]*$temperature{n};
}

// Calculation of conservative variables.
$rule pointwise(
  ssQ{n}
  <-
  gagePressure{n}, density{n}, velocity{n}, temperature{n},
  mixtureEnthalpy{n}, vol{n}, Pambient
), constraint(singleSpecies, geom_cells) {
  Loci::Array<double, 5> & Q = $ssQ{n};
  
  double const P = $gagePressure{n}+$Pambient;
  double const rho = $density{n};
  double const e = $mixtureEnthalpy{n} - P/rho;
  double const e0 = e + 0.5*dot($velocity{n}, $velocity{n});
  double const vol = $vol{n};
  
  double const r = vol*rho;
  Loci::vector3d<double> m = vol*rho*$velocity{n};
  double const e = vol*rho*e0;
  
  Q[0] = m[0];
  Q[1] = m[1];
  Q[2] = m[2];
  Q[3] = e;
  Q[4] = r;
}

// -----------------------------------------------------------------------------
// Multi-species calculations.
// -----------------------------------------------------------------------------

// Calculation of mixture molecular weight.
$rule pointwise(mixtureW{n} <- speciesY{n}, speciesW, Ns),
  constraint(multiSpecies, geom_cells) {
  double rW = 0.0;
  for(int i = 0; i < $Ns; ++i) {
    rW += $speciesY{n}[i]/$speciesW[i];
  }
  $mixtureW{n} = 1.0/rW;
}

// Calculation of species molar fractions.
$rule pointwise(speciesX{n} <- speciesY{n}, mixtureW{n}, speciesW, Ns),
constraint(geom_cells), prelude {
  $speciesX{n}.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $speciesX{n}[i] = $speciesY{n}[i]*$mixtureW{n}/$speciesW[i];
  }
}

// Calculation of species specific heat.
$rule pointwise(speciesCp{n} <- speciesCp_Constant, Ns),
constraint(multiSpecies, caloricallyPerfectGas, geom_cells), prelude {
  $speciesCp{n}.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    speciesCp{n}[i] = $speciesCp_Constant[i];
  }
}

// Calculation of species enthalpy.
$rule pointwise(speciesEnthalpy{n} <- temperature{n}, speciesCp_Constant, Ns),
constraint(multiSpecies, caloricallyPerfectGas, geom_cells), prelude {
  $speciesEnthalpy{n}.setVecSize(*$Ns);
} {
  for(int i = 0; i < $Ns; ++i) {
    $speciesEnthalpy{n}[i] = $speciesCp_Constant[i]*$temperature{n};
  }
}

// Calculation of mixture specific heat.
$rule pointwise(mixtureCp{n} <- speciesY{n}, speciesCp{n}, Ns),
constraint(multiSpecies, caloricallyPerfectGas, geom_cells) {
  $mixtureCp{n} = 0.0;
  for(int i = 0; i < $Ns; ++i) {
    $mixtureCp{n} += $speciesY{n}[i]*$speciesCp{n}[i];
  }
}

// Calculation of mixture enthalpy.
$rule pointwise(mixtureEnthalpy{n} <- speciesY{n}, speciesEnthalpy{n}, Ns),
constraint(multiSpecies, caloricallyPerfectGas, geom_cells) {
  $mixtureEnthalpy{n} = 0.0;
  for(int i = 0; i < $Ns; ++i) {
    $mixtureEnthalpy{n} += $speciesY{n}[i]*$speciesEnthalpy{n}[i];
  }
}

// Calculation of conservative variables.
$rule pointwise(
  msQ{n}
  <-
  gagePressure{n}, density{n}, velocity{n}, temperature{n}, speciesY{n},
  mixtureEnthalpy{n}, vol{n}, Pambient, Ns
), constraint(multiSpecies, geom_cells), prelude {
  $msQ{n}.setVecSize(*$Ns+4);
} {
  Vect<double> Q = $msQ{n};
  const_Vect<double> Y = $speciesY{n};
  
  double const P = $gagePressure{n}+$Pambient;
  double const rho = $density{n};
  double const e = $mixtureEnthalpy{n} - P/rho;
  double const e0 = e + 0.5*dot($velocity{n}, $velocity{n});
  double const vol = $vol{n};
  
  double const r = vol*rho;
  Loci::vector3d<double> m = vol*rho*$velocity{n};
  double const e = vol*rho*e0;
  
  Q[0] = m[0];
  Q[1] = m[1];
  Q[2] = m[2];
  Q[3] = e;
  Q[4] = r;
  for(int i = 0; i < $Ns-1; ++i) {
    Q[i+5] = Y[i]*r;
  }
}

// -----------------------------------------------------------------------------
// Both single-species and multi-species calculations

$rule pointwise(mixtureR{n} <- mixtureW{n}, Runiv),
constraint(geom_cells) {
  $mixtureR{n} = $Runiv/$mixtureW{n};
}

// =============================================================================
// Time loop advance: These are specific to the time integration scheme. Hence,
// they are written in files specific to the scheme.
// =============================================================================


// =============================================================================
// Time loop collapse.
// =============================================================================

$rule singleton(timeStepFinished{n} <- $n{n}, timeStep{n}, nTimeSteps) {
  $timeStepFinished{n} = $$n{n} >= $nTimeSteps;
}

$rule pointwise(solution <- gagePressure{n}, velocity{n}, temperature{n}),
constraint(geom_cells{n}, singleSpecies),
conditional(timeStepFinished{n}),
inplace(solution|gagePressure{n}), prelude {};

$rule pointwise(solution <- gagePressure{n}, velocity{n}, temperature{n},
speciesY{n}), constraint(geom_cells{n}, multiSpecies),
conditional(timeStepFinished{n}),
inplace(solution|gagePressure{n}), prelude {};

// =============================================================================

} // end: namespace flame
